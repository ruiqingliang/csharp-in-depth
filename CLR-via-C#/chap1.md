# 1. CLR 的执行模型
CLR: Common Luangue Runtime （公共语言运行时)

C# 源代码  =》 面向CLR 的C#编译器 =》 托管模块（PE32 or PE32+ 的可移植程序）
C++ 源代码 =》 面向CLR 的C++编译器 =》 托管模块（PE32 or PE32+ 的可移植程序）
...

托管模块组成：
1. 文件头：PE32 or PE32+、是否包含本地CPU执行（非托管代码）
2. CLR 头
2. 元数据（描述源代码中定义类型及成员与源代码中引用到的类型及成员）
3. IL （平台无关的中间代码）

元数据的作用有：
1. 可以做VS中的智能代码提示
2. 可以将对象数据序列化通过网络发送到目的地并反序列化生成对象。
3. JIT Compile 使用元数据验证IL代码
4. 协助垃圾收集器工作

IL 作用：
1. 基于栈实现，参数压入栈，返回值弹出栈。不面向具体指令，任何轻松实现面向CLR的代码。
2. IL指令是无类型，通过与元数据交互，可以知道 add a，b 的具体数据类型长度，真正运行时候编译成本地CPU指令。

IL 优化：
optimize- 不优化IL代码
optimize+ 优化IL代码
debug:full JIT 编译代码时将维护IL代码与本地指令的对应关系，方便提供调试


首次运行一个函数的执行过程：
```C#
static void Main()
{
    Console.WriteLine("hello world");
    Console.WriteLine("hello world2");
}
```

JIT Compiler 工作流程
1. 首先找到Console符号所在的程序集dll，然后通过元数据找到 WriteLine 的IL代码（这里标注为JIT 未编译）
2. 执行JIT 的验证，验证代码是否安全、验证函数参数合法性、验证返回值及类型正确性...
3. 申请一块内存
4. 编译IL代码，生成本地CPU指令，并放在刚申请的内存中
5. 找到IL代码，修改Flag 为刚申请的内存地址（这里修改标记为JIT 已编译）
6. 跳转到这个内存开始处执行代码

第二次运行一个函数的执行过程：
1. 首先找到Console符号所在的程序集dll，然后通过元数据找到 WriteLine 的IL代码（这里标注为JIT 已编译）
2. 跳转到JIT 编译完成的地址处执行指令。

托管代码的运行速度：
1. 首次执行时候需要JIT，稍慢
2. 第二次使用时，无需JIT，速度同执行本地指令一样。
3. 使用NGen.exe 在非运行时编译成本地指令（效果不如JIT好，原因是JIT在运行时编译，可以做一些只有运行时才确认的优化项，Ngen相对保守）
4. 也可以使用System.Runtime.ProfileOptimization 记录JIT的代码，下次启动程序，启用多个线程进行这部分的JIT

程序集的概念：
1. 将一组代码、数据、资源打包未一个完整体（dll）。
2. 当一个dll并非必要，可以不放在发布包中，而是使用时网络下载并动态加载。


AppDomain：
JIT 会验证IL代码是否访问了非法的内存地址，可以实现在一个进程中，运行多个应用程序。每个应用程序都在这个进程的虚拟内存地址中。
每个应用程序称为一个AppDomian。

非托管代码：
1. 需要标记为unsafe.
2. JIT 是会检查是否有执行权限，是否跳过验证部分。
3. 本地加载或者共享网络加载，默认有执行权限。
4. 网络下载dll运行，默认无执行权限。